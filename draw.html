<html>
    <head>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.css"/>
<script src="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.js"></script>
    </head>
    <body>
        <div>
        <canvas id="canvas" style="border: 1px solid" width="1000" height="700"></canvas>
        </div>
        <br /><hr />
        <input type="text" id="colorpicker" size=15 data-coloris value="#000000" style="font-size: 32px;"></input>
        <select name="brushwidth" id="brushwidth" style="font-size: 32px;">
            <option value="1">1px</option>
            <option value="2" selected >2px</option>
            <option value="3">3px</option>
            <option value="4">4px</option>
            <option value="5">5px</option>
            <option value="6">6px</option>
            <option value="7">7px</option>
            <option value="8">8px</option>
            <option value="9">9px</option>
            <option value="10">10px</option>
        </select>
        <br /><br />
        Chat: <input type="text" size="100" id="chatinput" />
        <ul id="chat"></ul>
        <h1>Coordinates: <span id="coords"></span></h1>
        <h3>Received: <span id="wsreceived"></span></h3>
        <h3>Sent: <span id="wssent"></span></h3>
        <h3>Delay: Server - <span id="serverdelay"></span>ms, Client <span id="clientdelay"></span>ms</h3>
        <button onclick="sendCanvasClear()">Clear Canvas and Delete history for everyone.</button>
    </body>
    <script>

        function isValidUUID(str) {
            const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
            return regexExp.test(str)
        }

        let wsReceived = 0;
        let wsSent = 0;
        const coords = document.getElementById("coords")
        const wsreceived = document.getElementById("wsreceived")
        const wssent = document.getElementById("wssent")
        const serverdelay = document.getElementById("serverdelay")
        const clientdelay = document.getElementById("clientdelay")
        const colorpicker = document.getElementById("colorpicker")
        const brushwidth = document.getElementById("brushwidth")
        const chatinput = document.getElementById("chatinput")

        chatinput.addEventListener("keyup", function(e) {

            if (e.keyCode === 13) {
                const chatMessage = {
                    m: chatinput.value,
                    t: "chat"
                }
                wsSendObject(chatMessage)
                chatinput.value = ""
            }
        })

        Coloris({
            alpha: false,
        })

        let ws;
        async function getCanvasUUID() {
            let canvas_uuid = window.location.hash.substr(1)
            if (!(isValidUUID(canvas_uuid))) {
                const response = await fetch(`${location.protocol}//${window.location.host}/uuid/new`)
                const data = await response.json()
                window.location.hash = `#${data.uuid}`
                canvas_uuid = data.uuid
                startWebSocket(data.uuid)
            }
            else {
                startWebSocket(canvas_uuid)
            }
        }

        getCanvasUUID()

        function startWebSocket(canvas_uuid) {
            if (location.protocol !== 'https:') {
                ws = new WebSocket(`ws://${window.location.host}/ws/${canvas_uuid}`)
            }
            else {
                ws = new WebSocket(`wss://${window.location.host}/ws/${canvas_uuid}`)
            }

            ws.onopen = function() {
                fetch(`${location.protocol}//${window.location.host}/sub/${canvas_uuid}`)
                clearAllCanvases()
                ws.send(JSON.stringify({
                    t: "connected"
                }))
            }
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data)
                const d = new Date()
                data.cdelay = d.getTime() - data.ctime
                wsReceived++
                wsreceived.textContent = wsReceived
                serverdelay.textContent = data.sdelay
                clientdelay.textContent = data.cdelay
                //console.log(data)
                if (data.t === 'line') {
                    drawAllCanvas(data.fx, data.fy, data.tx, data.ty, data.color, data.width)
                }
                else if (data.t === 'point') {
                    drawPointToAllAllCanvas(data.x, data.y, data.color, data.width)
                }
                else if (data.t === 'clear') {
                    clearAllCanvases()
                }
                else if (data.t === 'chat') {
                    let chat = document.getElementById("chat")
                    let li = document.createElement("li")
                    li.appendChild(document.createTextNode(data.m))
                    chat.prepend(li)
                }
            }

            ws.onclose = function() {
                ws = null
                setTimeout(() => {
                    startWebSocket(canvas_uuid)
                },
                2000)
            }
        }

        function wsSendObject(obj) {
            const d = new Date()
            obj.ctime = d.getTime()
            ws.send(JSON.stringify(obj))
            wsSent++
            wssent.textContent = wsSent
        }

        function sendCanvasCoords(canvas, fx, fy, tx, ty) {
            wsSendObject({
                c: canvas,
                fx: fx,
                fy: fy,
                tx: tx,
                ty: ty,
                color: colorpicker.value,
                width: brushwidth.value,
                t: 'line'
            })
        }
        function sendPointCoords(canvas, x, y) {
            wsSendObject({
                c: canvas,
                x: x,
                y: y,
                color: colorpicker.value,
                width: brushwidth.value,
                t: 'point'
            })
        }

        function sendCanvasClear() {
            wsSendObject({
                t: 'clear'
            })
        }

        const canvases = [
            "canvas"
        ]


        let localX = 0
        let localY = 0

        let c = {}
        for (let canv of canvases) {
            cv = document.getElementById(canv)
            c[canv] = {
                name: canv,
                canvas: cv,
                ctx: cv.getContext('2d'),
                source: 'foo'
            }
            cv.addEventListener('mousemove', function(e) {
                if (e.buttons !== 1) return;
                const { realX, realY } = getRealCoordinates(c[canv], e.clientX, e.clientY);
                sendCanvasCoords(c[canv].name, localX, localY, realX, realY)
                localX = realX
                localY = realY
            });

            cv.addEventListener('mousedown', function(e) {
                const { realX, realY } = getRealCoordinates(c[canv], e.clientX, e.clientY);
                localX = realX
                localY = realY
                sendPointCoords(c[canv].name, realX, realY)
            })

            cv.addEventListener('touchstart', function(e) {
                e.preventDefault()

                const { realX, realY } = getRealCoordinates(c[canv], e.touches[0].clientX, e.touches[0].clientY);
                localX = realX
                localY = realY
                sendPointCoords(c[canv].name, realX, realY)
            })

            cv.addEventListener('touchmove', function(e) {
                e.preventDefault()
                const { realX, realY } = getRealCoordinates(c[canv], e.touches[0].clientX, e.touches[0].clientY);
                sendCanvasCoords(c[canv].name, localX, localY, realX, realY)
                localX = realX
                localY = realY
            })
        }

        function drawAllCanvas(fx, fy, tx, ty, color, width) {
            for (const [_, canvas] of Object.entries(c)) {
                drawCanvas(canvas, fx, fy, tx, ty, color, width)
            }
        }

        function drawCanvas(canvas, fx, fy, tx, ty, color, width) {
            canvas.ctx.beginPath()
            canvas.ctx.lineWidth = width;
            canvas.ctx.lineCap = 'round'
            canvas.ctx.moveTo(fx, fy)
            canvas.ctx.lineTo(tx, ty)
            canvas.ctx.strokeStyle = color
            canvas.ctx.stroke()
            coords.textContent = `${tx}, ${ty}`
        }

        function drawPointToAllAllCanvas(x, y, color, width) {
            for (const [_, canvas] of Object.entries(c)) {
                drawPointToCanvas(canvas, x, y, color, width)
            }
        }
        function drawPointToCanvas(canvas, x, y, color, width) {
            canvas.ctx.beginPath()
            canvas.ctx.strokeStyle = color
            canvas.ctx.fillStyle = color
            canvas.ctx.lineWidth = 1
            canvas.ctx.arc(x, y, width/2, 0, 2*Math.PI)
            canvas.ctx.fill()
            coords.textContent = `${x}, ${y}`
        }

        function clearAllCanvases() {
            for (const [_, canvas] of Object.entries(c)) {
                clearCanvas(canvas)
            }
        }
        function clearCanvas(canvas) {
            canvas.ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            canvas.ctx.fillRect(0,0,canvas.canvas.width,canvas.canvas.height);
        }

        function getRealCoordinates(canvas, x, y) {
            const rect = canvas.canvas.getBoundingClientRect();
            const realX = x - rect.left
            const realY = y - rect.top;
            return { realX, realY };
        }


    </script>
</html>